<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" id="themeJQ" href="../../../css/themes/default/theme-default.min.css"/>
	<link rel="stylesheet" href="../../../css/themes/default/jquery.mobile.structure-1.2.0.min.css"/>
	<link rel="stylesheet" id="themeDocs" href="../../../css/docs-default.css"/>
	<script src="../../../js/energize-min.js"></script>
	<script src="../../../js/jquery-1.8.1.min.js"></script>
	<script src="../../../../app.js"></script>
	<script src="../../../js/common.js"></script>
	<script src="../../../js/example.js"></script>
	<script src="../../../js/jquery.mobile-1.2.0.min.js"></script>
	
	<link href="../../css/docs.css" rel="stylesheet" type="text/css"/>
	<link href="../../css/mathml.css" rel="stylesheet" type="text/css"/>

	<script> function jsxref(a,b,c,d,e) { document.write("<b>"+b+"</b>"); }</script>
	<script> function Note(s) { document.write("Note: "+s); }</script>
	<script> function anch(s) { document.write(s); }</script>
</head>
 
<body>

<div data-role="page" data-theme="a" data-ajax="false">

	<div data-role="header" data-position="fixed">
		<a href='#' class='ui-btn-left' data-icon='arrow-l' data-theme="c" onclick="history.back(); return false">Back</a> <h1><i>str</i>.charAt()</h1>
	</div><!-- /header -->

	<div data-role="content">
		<div><h2><i>str</i>.charAt()</h2></div>

<p>The <strong><code>charAt()</code></strong> method returns the specified character from a string.</p>

<h2 id="Syntax">Syntax</h2>

<pre class="syntaxbox"><code><var>str</var>.charAt(<var>index</var>)</code></pre>

<h3 id="Parameters">Parameters</h3>

<dl>
 <dt><code>index</code></dt>
 <dd>An integer between 0 and 1-less-than the length of the string.</dd>
</dl>

<h2 id="Description">Description</h2>

<p>Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called <code>stringName</code> is <code>stringName.length - 1</code>. If the <code>index</code> you supply is out of range, JavaScript returns an empty string.</p>

<h2 id="Examples">Examples</h2>

<h3 id="Displaying_characters_at_different_locations_in_a_string">Displaying characters at different locations in a string</h3>

<p>The following example displays characters at different locations in the string <code>"Brave new world"</code>:</p>

<pre class="brush: js">var anyString = 'Brave new world';

console.log("The character at index 0   is '" + anyString.charAt(0)   + "'");
console.log("The character at index 1   is '" + anyString.charAt(1)   + "'");
console.log("The character at index 2   is '" + anyString.charAt(2)   + "'");
console.log("The character at index 3   is '" + anyString.charAt(3)   + "'");
console.log("The character at index 4   is '" + anyString.charAt(4)   + "'");
console.log("The character at index 999 is '" + anyString.charAt(999) + "'");
</pre>

<p>These lines display the following:</p>

<pre class="brush: js">The character at index 0   is 'B'
The character at index 1   is 'r'
The character at index 2   is 'a'
The character at index 3   is 'v'
The character at index 4   is 'e'
The character at index 999 is ''
</pre>

<h3 id="Getting_whole_characters">Getting whole characters</h3>

<p>The following provides a means of ensuring that going through a string loop always provides a whole character, even if the string contains characters that are not in the Basic Multi-lingual Plane.</p>

<pre class="brush: js">var str = 'A \uD87E\uDC04 Z'; // We could also use a non-BMP character directly
for (var i = 0, chr; i &lt; str.length; i++) {
  if ((chr = getWholeChar(str, i)) === false) {
    continue;
  }
  // Adapt this line at the top of each loop, passing in the whole string and
  // the current iteration and returning a variable to represent the 
  // individual character

  console.log(chr);
}

function getWholeChar(str, i) {
  var code = str.charCodeAt(i);

  if (isNaN(code)) {
    return ''; // Position not found
  }
  if (code &lt; 0xD800 || code &gt; 0xDFFF) {
    return str.charAt(i);
  }

  // High surrogate (could change last hex to 0xDB7F to treat high private
  // surrogates as single characters)
  if (0xD800 &lt;= code &amp;&amp; code &lt;= 0xDBFF) {
    if (str.length &lt;= (i + 1)) {
      throw 'High surrogate without following low surrogate';
    }
    var next = str.charCodeAt(i + 1);
      if (0xDC00 &gt; next || next &gt; 0xDFFF) {
        throw 'High surrogate without following low surrogate';
      }
      return str.charAt(i) + str.charAt(i + 1);
  }
  // Low surrogate (0xDC00 &lt;= code &amp;&amp; code &lt;= 0xDFFF)
  if (i === 0) {
    throw 'Low surrogate without preceding high surrogate';
  }
  var prev = str.charCodeAt(i - 1);

  // (could change last hex to 0xDB7F to treat high private
  // surrogates as single characters)
  if (0xD800 &gt; prev || prev &gt; 0xDBFF) {
    throw 'Low surrogate without preceding high surrogate';
  }
  // We can pass over low surrogates now as the second component
  // in a pair which we have already processed
  return false;
}
</pre>

<p>In an exclusive JavaScript 1.7+ environment (such as Firefox) which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does incrementing for an incrementing variable automatically (if the character warrants it in being a surrogate pair).</p>

<pre class="brush: js">var str = 'A\uD87E\uDC04Z'; // We could also use a non-BMP character directly
for (var i = 0, chr; i &lt; str.length; i++) {
  [chr, i] = getWholeCharAndI(str, i);
  // Adapt this line at the top of each loop, passing in the whole string and
  // the current iteration and returning an array with the individual character
  // and 'i' value (only changed if a surrogate pair)

  console.log(chr);
}

function getWholeCharAndI(str, i) {
  var code = str.charCodeAt(i);

  if (isNaN(code)) {
    return ''; // Position not found
  }
  if (code &lt; 0xD800 || code &gt; 0xDFFF) {
    return [str.charAt(i), i]; // Normal character, keeping 'i' the same
  }

  // High surrogate (could change last hex to 0xDB7F to treat high private 
  // surrogates as single characters)
  if (0xD800 &lt;= code &amp;&amp; code &lt;= 0xDBFF) {
    if (str.length &lt;= (i + 1)) {
      throw 'High surrogate without following low surrogate';
    }
    var next = str.charCodeAt(i + 1);
      if (0xDC00 &gt; next || next &gt; 0xDFFF) {
        throw 'High surrogate without following low surrogate';
      }
      return [str.charAt(i) + str.charAt(i + 1), i + 1];
  }
  // Low surrogate (0xDC00 &lt;= code &amp;&amp; code &lt;= 0xDFFF)
  if (i === 0) {
    throw 'Low surrogate without preceding high surrogate';
  }
  var prev = str.charCodeAt(i - 1);

  // (could change last hex to 0xDB7F to treat high private surrogates
  // as single characters)
  if (0xD800 &gt; prev || prev &gt; 0xDBFF) {
    throw 'Low surrogate without preceding high surrogate';
  }
  // Return the next character instead (and increment)
  return [str.charAt(i + 1), i + 1];
}
</pre>

<h3 id="Fixing_charAt()_to_support_non-Basic-Multilingual-Plane_(BMP)_characters">Fixing <code>charAt()</code> to support non-Basic-Multilingual-Plane (BMP) characters</h3>

<p>While the example above may be more frequently useful for those wishing to support non-BMP characters (since it does not require the caller to know where any non-BMP character might appear), in the event that one <em>does</em> wish, in choosing a character by index, to treat the surrogate pairs within a string as the single characters they represent, one can use the following:</p>

<pre class="brush: js">function fixedCharAt(str, idx) {
  var ret = '';
  str += '';
  var end = str.length;

  var surrogatePairs = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  while ((surrogatePairs.exec(str)) != null) {
    var li = surrogatePairs.lastIndex;
    if (li - 2 &lt; idx) {
      idx++;
    } else {
      break;
    }
  }

  if (idx &gt;= end || idx &lt; 0) {
    return '';
  }

  ret += str.charAt(idx);

  if (/[\uD800-\uDBFF]/.test(ret) &amp;&amp; /[\uDC00-\uDFFF]/.test(str.charAt(idx + 1))) {
    // Go one further, since one of the "characters" is part of a surrogate pair
    ret += str.charAt(idx + 1);
  }
  return ret;
}
</pre>







<div></div>







 
		<br>
		<p class="lic">&nbsp;<a class="lic" id="extLink" href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" target="_blank" data-role="none">
		Created by Mozilla Contributors</a>, license: <a class="lic" id="extLink" href="http://creativecommons.org/licenses/by-sa/2.5" target="_blank" data-role="none">CC-BY-SA 2.5</a>
		</p>
	</div>
</div>

</body>
</html>
 